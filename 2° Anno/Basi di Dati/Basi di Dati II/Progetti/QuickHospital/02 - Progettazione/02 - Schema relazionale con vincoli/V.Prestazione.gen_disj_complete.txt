Progettazione del vincolo esterno ristrutturato (si lasciano tutti gli altri per esercizio!!):

[V.Prestazione.gen_disj_complete]	
	ALL prest    Prestazione(prest) --> [
					// disjoint
					not EXISTS r, pe   
							r_isa_p(r, prest) and pe_isa_p(pe, prest)
					and
					// complete
					(  EXISTS x r_isa_p(x, prest) or pe_isa_p(x, prest) )
	
	].

Strategia:
	- Politiche di accesso ai dati + trigger




Politiche di accesso ai dati:
	impedisci:
		UPDATE su Prestazione(id)
		UPDATE su PrestazioneFinalizzata(id)
		UPDATE su PrestazioneNonFinalizzata(id)


Trigger:
	Istante di intercettazione: AFTER
	Eventi intercettati:
		INSERT(new) in Prestazione
		INSERT(new) in PrestazioneNonFinalizzata
		INSERT(new) in PrestazioneFinalizzata
		DELETE(old) in PrestazioneNonFinalizzata
		DELETE(old) in PrestazioneNonFinalizzata

	Funzione(old, new):
		// a causa degli eventi, esattamente una tra old e new è non-NULL.

		id integer = NULL 

		if evento è INSERT:
			id = new.id
		else if evento è DELETE
			id = old.id
		else:
			errore, evento non previsto

		error Boolean = FALSE
		
		SELECT count(*) <> 1 INTO STRICT error
		FROM PrestazioneFinalizzata pf, PrestazioneNonFinalizzata pnf
		WHERe pf.prestazione = id AND pnf.prestazione = id;

		if error:
			errore, disjoint e complete non soddisfatti

		return NULL;


	Nota: Dato che intercettiamo eventi su tre tabelle, abbiamo bisogno di tre trigger, ma riusciamo ad usare la stessa funzione.