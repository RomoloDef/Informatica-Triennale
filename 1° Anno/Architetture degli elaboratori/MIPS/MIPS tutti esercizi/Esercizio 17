#  Considerate la regola di Collatz: dato un numero intero positivo n, se n è pari lo si divide per 2, se è dispari lo si moltiplica per 3 e si aggiunge 1 al risultato. Quando n è 1 ci si ferma.
# Ad esempio, la sequenza di Collatz di 7 è: 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
# E' un noto problema aperto stabilire se ogni sequenza di Collatz termina (cioè, se arriva a 1). Scrivere in linguaggio assemblativo MIPS/MARS una funzione che, dato un numero, dia il successivo in una sequenza di Collatz. Quindi, usare la funzione in un programma che chiede all’utente un numero e mostra la sequenza di Collatz del numero e la lunghezza.
# Esempi di funzionamento
# Numero: 7
# 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
# Lunghezza: 17
# Numero: 9 9 28 14 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
# Lunghezza: 20

.text
.globl main

main:

	li $t1, 1		# carico il valore uno per fare de confronti
	li $t9, 0		# inizializzo la sequenza a 0
	la $t8, sequenza 	# carico l'indirizzo della stringa di output
	
	li $v0, 4	# carico il codice per la syscall
	la $a0, n	# carico la stringa
	syscall
	
	li $v0, 5	# carico il codice per leggere l'intero
	syscall
	move $t0, $a0	# sposto il valore letto nel registro $t0
	
	jal CALCOLO
	
	 # Stampo la sequenza di numeri della successione di Collatz
    	li $v0, 4
    	la $a0, sequenza    # Carica l'indirizzo della stringa di output
    	syscall

    	# Stampo la lunghezza della sequenza
    	li $v0, 4
    	la $a0, messaggio   # Carica l'indirizzo del messaggio per la lunghezza
    	syscall

    	# Stampo la lunghezza calcolata della sequenza
    	li $v0, 1
    	move $a0, $t9        # Carica la lunghezza della sequenza da $t9
   	syscall
	
	li $v0, 10
	syscall
	
CALCOLO:
	addi $t9, $t9, 1	# incremento il valore della lunghezza di uno
	sw $t0, 0($t8)		# memorizzo il numero corrente
	addi $t8, $t8, 4	# passo all'elemento successivo
	# se n = 1 allora ci si ferma
	beq $t0, $t1, FINE	    
	# verifico se il numero è pari
	li $t2, 2	# carico il valore 2 per la divisione - se il resto è 0 allora è pari, se è il resto è maggiore di 0 allora è dispari
	div $t0, $t2	# divisione
	
	mfhi $t3	# carico il resto
	
	# ora vedo com'è il resto
	
	beq $t3, $zero, PARI
	j DISPARI
	
	PARI:
		div $t0, $t0, $t2	# divido il numero per 2
		j CALCOLO
		
	DISPARI:
		li $t4, 3		# carico il valore 3 per la moltiplicazione
		mul $t0, $t0, $t4	# numero per moltiplicazione
		add $t0, $t0, $t1	# si somma uno
		j CALCOLO
FINE:
	jr $ra
	
	

.data
n: .asciiz "Inserisci il tuo numero: "
sequenza: .space 512
messaggio: .asciiz "La lunghezza è: "